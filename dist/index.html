<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple-WebGPU Graphics Engine</title>
    <link
      href="./data/tailwind.min.css"
      rel="stylesheet"
    />
    <style>
      body {
        background: #333;
      }
      
      #container * {
        position: absolute;
        top: 0px;
        left: 0px;

        width: 100%;
        height: 100%;
        padding: 25px;
      }

      canvas {
        position: absolute;
        left: 0px;
        top: 0px;
      }

      #embed {
        opacity: 0.1;
        height: 200px;
        width: 200px;
        padding-top: 50px;
      }

      #control-panel {
        z-index: 124;
        position: absolute;
      }
      #control-panel {
        background: steelblue;
        position: absolute;
        top: 0px;
        right: 0px;
        padding: 5px;
        color: lightgray;
      }

      #control-panel label {
        display: block;
        
      }
      #control-panel label:hover {
        background: pink;
        
      }
      canvas {
        z-index: 0;
        position: absolute;
        width: 500px;
        height: 500px;
      }
      audio {
        position: absolute;
        top: 50px;
        left: 50px;
        z-index: 999;
      }

    </style>
    
    <script type="module" src="./my-lib.es.js"></script>
    <script type="module">
      //import simpleWebgpu from "../lib/main";
import simpleWebgpu from '../lib/main';

// Calling simplewebgpu.init() creates a new partially evaluated draw command
let webgpu = await simpleWebgpu.init()
//console.log(webgpu)
//module thinks this is a draw call but its actually an init draw call


// webgpu.frame() wraps requestAnimationFrame and also handles viewport changes

function basic () {
  let time = 0
 
 webgpu.initDrawCall({
    // Shaders in simplewebgpu. are just strings.  You can use glslify or whatever you want
    // to define them.  No need to manually create shader objects.
    frag: `
    @fragment
    fn main(
      //@location(0) position: vec4<f32>,
      //@location(1) color: vec4<f32>,
    ) -> @location(0) vec4<f32> {
      //return color;
      return vec4(${Math.random()}, 0.0, .9, 1.0);
    }`,
  
    vert: `
    struct VertexOutput {
      @builtin(position) Position : vec4<f32>,
     // Color: vec3<f32>,
    }
  
    @vertex
    fn main (
      @builtin(vertex_index) VertexIndex : u32,
      @location(0) position : vec2<f32>,
      @location(1) color : vec3<f32>,
    ) -> VertexOutput {
  
    var output: VertexOutput;
    //output.Color = color;
  
    output.Position = vec4<f32>(position.xy, 0.0, 1.0);
    return output;
    }`,
  
    // Here we define the vertex attributes for the above shader
    attributes: {
      // simplewebgpu.buffer creates a new array buffer object
      position: webgpu.buffer([
        [.0, .5],   // no need to flatten nested arrays, simpleWebgpu automatically
        [-0.5, -0.5],    // unrolls them into a typedarray (default Float32)
        [.5,  -.5]
      ]), color: webgpu.buffer([
        [1,0,0],
        [0,1,0],
        [1,0,1],
      ])
      // simpleWebgpu automatically infers sane defaults for the vertex attribute pointers
    },
  
    uniforms: {
      // This defines the color of the triangle to be a dynamic variable
      color: webgpu.prop('color')
    },
    // This tells simpleWebgpu the number of vertices to draw in this command
    count: 3
  }).then(draw => {
    draw({
      color: [
        Math.cos(time * 0.001),
        Math.sin(time * 0.0008),
        Math.cos(time * 0.003),
        1
      ]
    })

    draw({
      color: [
        Math.cos(time * 0.001),
        Math.sin(time * 0.0008),
        Math.cos(time * 0.003),
        1
      ]
    })
  })
}

basic()

// simpleWebgpu.frame(({time}) => {
//   // clear contents of the drawing buffer
//   simpleWebgpu.clear({
//     color: [0, 0, 0, 0],
//     depth: 1
//   })

//   // draw a triangle using the command defined above
//   drawTriangle({
//     color: [
//       Math.cos(time * 0.001),
//       Math.sin(time * 0.0008),
//       Math.cos(time * 0.003),
//       1
//     ]
//   })
// })
    </script>
  </head>
  <body>

    <div id="swap" class="mt-4">
      <form name="stuff">
        <fieldset>
      <div id="control-panel" class="mt-2">
                  <label class="inline-flex items-center">
          basic
                            <input
                            type="radio"
                            class="form-radio"
                            name="basic"
                            value="basic"
                          />
                          </label>
                          <label class="inline-flex items-center">
          hello
                          <input
                          type="radio"
                          class="form-radio"
                          name="hello"
                          value="hello"
                          checked
                        />
                      </label>
      
      </div>
    </fieldset>
      </form>
      <!-- <canvas height="500" width="960"></canvas> -->

      <div class=" font-white bg-purple-700">
        <a link="https://github.com/shelbernstein/Simple-webgpu/blob/main/readme.md">
          Readme
        </a>
        <a link="https://github.com/shelbernstein/Simple-webgpu/blob/main/API.md">
          API
        </a>
        <a link="/https://github.com/shelbernstein/Simple-webgpu">
          GitHub
        </a>
      </div>
    </div>
   
  </body>
</html>

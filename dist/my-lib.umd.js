var N=Object.defineProperty,V=Object.defineProperties;var I=Object.getOwnPropertyDescriptors;var w=Object.getOwnPropertySymbols;var O=Object.prototype.hasOwnProperty,_=Object.prototype.propertyIsEnumerable;var v=(c,u,d)=>u in c?N(c,u,{enumerable:!0,configurable:!0,writable:!0,value:d}):c[u]=d,U=(c,u)=>{for(var d in u||(u={}))O.call(u,d)&&v(c,d,u[d]);if(w)for(var d of w(u))_.call(u,d)&&v(c,d,u[d]);return c},G=(c,u)=>V(c,I(u));(function(c,u){typeof exports=="object"&&typeof module!="undefined"?module.exports=u():typeof define=="function"&&define.amd?define(u):(c=typeof globalThis!="undefined"?globalThis:c||self,c.MyLib=u())})(this,function(){"use strict";const c=(e,r,n)=>{let t={size:r.byteLength+3&~3,usage:n,mappedAtCreation:!0},a=e.createBuffer(t);return r[5]=Date.now(),(r instanceof Uint16Array?new Uint16Array(a.getMappedRange()):new Float32Array(a.getMappedRange())).set(r),a.unmap(),a},u=function(e,r){e.addEventListener("mousemove",n=>{let t=n.pageX,a=n.pageY;r.mouseX=t/n.target.clientWidth,r.mouseY=a/n.target.clientHeight})};function d(e=500,r=500){let n=devicePixelRatio;var t=document.createElement("canvas");return t.width=n*e,t.height=n*r,t.style.width=e+"px",document.body.appendChild(t),t}var x={createBuffer:c,createCanvas:d,addMouseEvents:u};let E=async e=>{const r=document.createElement("img"),n=r;return n.width=innerWidth,n.height=innerHeight,r.src=e.data.texture,await r.decode(),await createImageBitmap(r)};async function A(e){var r,n;if(HTMLImageElement===((n=(r=e==null?void 0:e.data)==null?void 0:r.texture)==null?void 0:n.constructor)){let t=e.data.texture;await t.decode(),await createImageBitmap(t),await t.decode();let a=await createImageBitmap(t),i=e.device.createTexture({size:[a.width,a.height,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return e.device.queue.copyExternalImageToTexture({source:a},{texture:i},[a.width,a.height]),e.texture=i,p(e),i}else if(typeof e.data.texture=="string"){let t=e.device.createTexture({size:[900,500,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),a=await E(e);return e.device.queue.copyExternalImageToTexture({source:a},{texture:t},[a.width,a.height]),e.texture=t,p(e),t}else{let t=e.device.createTexture({size:[256,1,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}),a=new Float32Array(new Array(800).fill(5).map((i,s)=>e.data.texture?e.data.texture[s%e.data.texture.length+i]:Math.random()));return e.texture=t,e.data.music=a,p(e),t}}function p(e){if(!!e.texture&&e.data.texture){let r=new Uint8Array(new Array(1024).fill(5).map((n,t)=>e.data.texture?e.data.texture[t%e.data.texture.length]:Math.random()));e.device.queue.writeTexture({texture:e.texture},r.buffer,{bytesPerRow:3200,rowsPerImage:600},[256,1])}}function y(e){let{data:r,device:n}=e,t=Object.values(r).filter(i=>typeof i!="object"),a=new Float32Array(t.length);return a.set(t,0),e.uniformsBuffer?(n.queue.writeBuffer(e.uniformsBuffer,0,a.buffer,0,4*a.length),e.uniformsBuffer):e.uniformsBuffer=x.createBuffer(n,a,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST)}function B(e){var s;let{particleBuffers:r,computeVertexBufferData:n,device:t}=e;const a=t.createBindGroup(e.bindGroupDescriptor),i={renderPassDescriptor:e.renderPassDescriptor,texture:e.texture,pipeline:e.pipeline,bindGroup:a,type:"draw"};((s=e==null?void 0:e.compute)==null?void 0:s.numVertices)&&(i.numVertices=e.compute.numVertices()),e.compute&&r&&(i.vertexBuffers=[r[0],n]),e.renderPasses.push(i)}const D=async function(e){let{device:r,renderPassDescriptor:n}=e;n.colorAttachments[0].view=e.context.getCurrentTexture().createView();const t=r.createCommandEncoder();let a=e.renderPasses[0];if(!a)return console.log("no worky");let i=new Float32Array(e.options.attributes.position.array.flat());const s=r.createBuffer({size:i.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(s.getMappedRange()).set(i),s.unmap();let o=t.beginRenderPass(n);o.setPipeline(a.pipeline),o.setBindGroup(0,a.bindGroup),o.setVertexBuffer(0,s),o.draw(3,1,0,0),o.end(),r.queue.submit([t.finish()])};async function R(e){let{device:r}=e;const n=new Float32Array(new Array(1e4).fill(5).map((g,b)=>{let P=b/1e3;if(b%2==1)return P%1;if(b%2==0)return P/10})),t=r.createBuffer({size:n.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(t.getMappedRange()).set(n),t.unmap(),e.cubeVertices=t;let a={layout:"auto",vertex:{module:r.createShaderModule({code:e.options.vert}),entryPoint:"main",buffers:[{arrayStride:2*4,attributes:[{shaderLocation:0,offset:0,format:"float32x2"},{shaderLocation:1,offset:0,format:"float32x2"}]}]},fragment:{module:r.createShaderModule({code:e.options.frag}),entryPoint:"main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}};e.compute&&applyCompute(f.vertexBuffers);const i=r.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:"nearest"}),s=r.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform",minBindingSize:4*7}},{binding:1,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,type:"sampler",sampler:i},{binding:2,visibility:GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,texture:{}}]}),o=r.createPipelineLayout({bindGroupLayouts:[s]});e.bindGroupLayout=s,y(e);const T={colorAttachments:[{view:void 0,clearValue:{r:.5,g:.5,b:.5,a:1},loadOp:"clear",storeOp:"store"}]};e.renderPassDescriptor=T;let f=r.createRenderPipeline(G(U({},a),{layout:o})),l=await A(e);return e.bindGroupDescriptor={layout:f.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:e.uniformsBuffer}},{binding:1,resource:i},{binding:2,resource:l.createView({baseMipLevel:0,mipLevelCount:1}),texture:{sampleType:"float",viewDimension:"2d",multisampled:0}}]},e.bindGroupDescriptor.entries[0].resource.buffer=y(e),e.bindGroupDescriptor.entries[2].resource=l.createView({baseMipLevel:0,mipLevelCount:1}),f}async function C(e,r){e.options.shader,e.pipeline=await R(e),B(e)}let M={width:innerWidth,height:innerHeight,pixelRatio:2,time:0,mouseX:0,mouseY:0,angle:0};async function S(e={}){let r=e.canvas||x.createCanvas();const n={renderPassDescriptor:{},options:e,data:Object.assign(M,e.data),compute:e.compute,renderPasses:[]};if(x.addMouseEvents(r,n.data),!navigator.gpu)return console.log("Error: webgpu is not available. Please install canary!!!");const t=r.getContext("webgpu"),a=await navigator.gpu.requestAdapter(),i=await(a==null?void 0:a.requestDevice()),s=navigator.gpu.getPreferredCanvasFormat();Object.assign(n,{device:i,context:t,adapter:a}),t.configure({device:i,format:s,alphaMode:"opaque",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});function o(l){return Array.isArray(l)?l.map(g=>o(g)):(p(n),y(n),D(n),o)}return o.canvas=r,o.prop=h,o.buffer=m,o.initDrawCall=f,o.state=n,o.draw=o,{initDrawCall:f,buffer:m,prop:h,clear:L,frame:T,version:"0.10.0"};function T(l){requestAnimationFrame(function g(){l(),requestAnimationFrame(g)})}async function f(l){return n.options=l,await C(n,n.options),o}}function L(e){state.clearValue.r=e.color[0],state.clearValue.g=e.color[1],state.clearValue.b=e.color[2]}function m(e){if(!(this instanceof m))return new m(e);this.array=e}function h(e){return()=>state.uniforms.color}var F={init:S};return F});
